{"version":3,"file":"static/js/lezer-vendor.8536dbbd.js","mappings":"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","sources":["../node_modules/@lezer/common/dist/index.js","../node_modules/@lezer/highlight/dist/index.js","../node_modules/@lezer/lr/dist/index.js","../node_modules/@lezer/json/dist/index.es.js"],"sourcesContent":["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && !c.type.isAnonymous)\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given contexta sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n","import { NodeProp } from '@lezer/common';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of this tag and all its parent tags, starting with\n    /// this one itself and sorted in order of decreasing specificity.\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\n    /// this tag will try to fall back to the parent tag (or grandparent\n    /// tag, etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelwildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope: scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle, \n/// The start of the range to highlight.\nfrom = 0, \n/// The end of the range.\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = type.prop(ruleNodeProp), opaque = false;\n        while (rule) {\n            if (!rule.context || cursor.matchContext(rule.context)) {\n                let tagCls = highlightTags(highlighters, rule.tags);\n                if (tagCls) {\n                    if (cls)\n                        cls += \" \";\n                    cls += tagCls;\n                    if (rule.mode == 1 /* Inherit */)\n                        inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n                    else if (rule.mode == 0 /* Opaque */)\n                        opaque = true;\n                }\n                break;\n            }\n            rule = rule.next;\n        }\n        this.startSpan(cursor.from, cls);\n        if (opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(to, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementif your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property or field [name](#highlight.tags.name).\n    propertyName: propertyName,\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    attributeName: t(propertyName),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\n    attributeValue: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) related to defining or\n    /// interfacing with modules.\n    moduleKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// [Content](#highlight.tags.content) that has a strike-through\n    /// style.\n    strikethrough: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\nexport { Tag, classHighlighter, highlightTree, styleTags, tagHighlighter, tags };\n","import { Parser, NodeSet, NodeType, DefaultBufferLength, NodeProp, Tree, IterMode } from '@lezer/common';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special casethey add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /// @internal\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// @internal\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsingwhen looking forwardor even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // , , , , , , , , , , , , , \n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// Holds the parse tables for a given grammar, as generated by\n/// `lezer-generator`, and provides [methods](#common.Parser) to parse\n/// content with.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 14 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    /// are registered for this parser.\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// Used by the output of the parser generator. Not available to\n    /// user code.\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Extend */ : 0 /* Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n","import { LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\nconst jsonHighlighting = styleTags({\n  String: tags.string,\n  Number: tags.number,\n  \"True False\": tags.bool,\n  PropertyName: tags.propertyName,\n  Null: tags.null,\n  \",\": tags.separator,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j\",\n  stateData: \"#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O\",\n  goto: \"!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \" JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 25,\n  nodeProps: [\n    [\"openedBy\", 7,\"{\",12,\"[\"],\n    [\"closedBy\", 8,\"}\",13,\"]\"]\n  ],\n  propSources: [jsonHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~\",\n  tokenizers: [0],\n  topRules: {\"JsonText\":[0,1]},\n  tokenPrec: 0\n});\n\nexport { parser };\n"],"names":["DefaultBufferLength","nextPropID","Range","from","to","this","NodeProp","config","id","perNode","deserialize","Error","match","RangeError","NodeType","type","result","undefined","closedBy","str","split","openedBy","group","contextHash","lookAhead","mounted","noProps","Object","create","name","props","flags","prop","indexOf","spec","length","top","skipped","error","src","Array","isArray","map","direct","f","node","groups","i","found","none","IterMode","NodeSet","types","newTypes","newProps","source","add","assign","push","CachedNode","WeakMap","CachedInnerNode","Tree","children","positions","value","overlay","tree","toString","test","isError","JSON","stringify","mode","TreeCursor","topNode","pos","side","scope","get","cursor","moveTo","set","_tree","TreeNode","resolveNode","enter","leave","c","IncludeAnonymous","entered","isAnonymous","firstChild","nextSibling","parent","balanceRange","propValues","makeTree","data","buildTree","empty","FlatBufferCursor","buffer","index","TreeBuffer","childString","join","endIndex","startIndex","dir","pick","checkSide","startI","endI","b","copy","Uint16Array","j","enterUnfinishedNodesBefore","scan","childBefore","last","lastChild","prevSibling","overlays","_a","IgnoreOverlays","inner","_parent","e","next","start","ExcludeBuffers","findChild","BufferNode","BufferContext","hasChild","IgnoreMounts","nextChild","rPos","val","nextSignificantParent","before","after","r","getChildren","context","matchNodeContext","cur","is","p","child","externalSibling","parentStart","slice","stack","bufferNode","yieldNode","n","unshift","yieldBuf","yield","enterChild","pop","d","sibling","atLastNode","move","cache","depth","mustLeave","some","ch","nodeSet","maxBufferLength","reused","minRepeatType","takeNode","minPos","inRepeat","end","size","lookAheadAtStart","startPos","maxSize","fork","skip","minStart","nodeSize","localSkipped","nodeStart","findBufferSize","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","lookAheadProp","lastI","makeBalanced","base","pair","concat","bufferStart","topID","nodeSizeCache","balanceType","mkTop","mkTree","total","maxChild","Math","ceil","divide","offset","groupFrom","groupStart","groupSize","nextSize","only","TreeFragment","openStart","openEnd","open","fragments","partial","changes","minGap","fI","nextF","cI","off","nextC","nextPos","fromA","cut","fFrom","max","fTo","min","toA","toB","Parser","input","ranges","StringInput","createParse","parse","startParse","done","advance","string","nextTagID","Tag","modified","tag","t","mod","Modifier","sort","a","nextModifierID","instances","mods","exists","find","every","x","configs","permute","array","styleTags","byName","tags","part","pieces","rest","m","exec","rule","Rule","ruleNodeProp","other","tagHighlighter","options","style","class","all","cls","sub","tagClass","highlightTags","highlighters","highlightTree","highlighter","putStyle","builder","HighlightBuilder","highlightRange","flush","at","span","inheritedClass","isTop","filter","h","opaque","matchContext","tagCls","startSpan","innerHighlighters","rangeFrom","rangeTo","define","comment","typeName","propertyName","literal","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","attributeName","className","labelName","namespace","macroName","docString","character","attributeValue","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","moduleKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","strikethrough","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","defineModifier","constant","function","standard","local","special","Recover","Stack","state","reducePos","score","bufferBase","curContext","_","action","parser","dPrec","dynamicPrecedence","pushState","getGoto","minRepeatTerm","storeNode","reduceContext","count","stateFlag","baseStateID","term","isReduce","nextEnd","nextState","maxNode","shiftContext","reduce","shift","updateContext","tracker","reuse","stream","reset","isNode","sim","SimulatedStack","stateSlot","hasAction","nextStates","s","best","v","validAction","target","forceReduce","dialectID","dialect","hash","newCx","StackContext","emitContext","emitLookAhead","strict","cx","goto","StackBufferCursor","maybeNext","CachedToken","extended","mask","nullToken","InputStream","chunk","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","range","readNext","assoc","idx","charCodeAt","resolved","resolveOffset","endOffset","nextChunk","getChunk","setDone","read","TokenGroup","groupMask","accEnd","allows","overrides","acceptToken","low","high","mid","readToken","prototype","contextual","fallback","extend","decodeArray","Type","out","stop","digit","Safety","verbose","process","LOG","stackIDs","cutAt","childAfter","Rec","FragmentCursor","fragment","safeFrom","safeTo","trees","nextFragment","fr","nextStart","TokenCache","tokens","mainToken","actions","tokenizers","actionIndex","main","tokenizer","updateCachedToken","addActions","setLookAhead","eofTerm","clipPos","specialized","specializers","putAction","Parse","recovering","nextStackID","minStackPos","stoppedAt","topTerm","stacks","bufferLength","stopped","stoppedTokens","newStacks","advanceStack","tok","getMainToken","finished","findFinished","stackToTree","console","log","getName","SyntaxError","runRecovery","forceAll","maxRemaining","outer","sameState","splice","stackID","strictCx","cxHash","cached","nodeAt","useNode","defaultReduce","getActions","localStack","apply","pushStackDedup","restarted","tokenEnd","deadEnd","restart","advanceFully","force","forceBase","recoverByInsert","insert","recoverByDelete","close","String","fromCodePoint","Dialect","disabled","LRParser","wrappers","version","nodeNames","repeatNodeCount","topTerms","keys","topRules","nodeProps","setProp","nodeID","propSpec","skippedNodes","propSources","tokenArray","tokenData","specializerSpecs","getSpecializer","states","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","w","loose","table","groupTag","terminal","slot","flag","prev","iPrev","findOffset","info","external","contextTracker","wrap","prec","values","Uint8Array","jsonHighlighting","Number","PropertyName","Null"],"sourceRoot":""}